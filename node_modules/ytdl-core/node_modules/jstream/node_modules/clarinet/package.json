{
  "name": "clarinet",
  "description": "SAX based evented streaming JSON parser in JavaScript (browser and node)",
  "author": {
    "name": "Nuno Job",
    "email": "nunojobpinto@gmail.com",
    "url": "http://nunojob.com/"
  },
  "contributors": [
    {
      "name": "Jann Horn",
      "url": "https://github.com/thejh"
    },
    {
      "name": "Justin Makeig",
      "email": "jmpublic+github@makeig.com",
      "url": "http://www.audiblepop.com"
    },
    {
      "name": "Roly Fentanes",
      "url": "http://about.me/roly"
    },
    {
      "name": "John Lancaster",
      "url": "http://jlank.com"
    }
  ],
  "version": "0.8.1",
  "main": "./clarinet.js",
  "homepage": "https://github.com/dscape/clarinet",
  "repository": {
    "type": "git",
    "url": "http://github.com/dscape/clarinet.git"
  },
  "bugs": {
    "url": "http://github.com/dscape/clarinet/issues"
  },
  "keywords": [
    "sax",
    "json",
    "parser",
    "stream",
    "streaming",
    "event",
    "events",
    "emitter",
    "async",
    "streamer",
    "browser"
  ],
  "devDependencies": {
    "mocha": "1.3.x",
    "should": "1.0.x",
    "underscore": "1.2.3"
  },
  "scripts": {
    "test": "./node_modules/mocha/bin/mocha -r should -t 10000 -s 2000  test/clarinet.js test/npm.js"
  },
  "engines": {
    "node": ">=0.3.6",
    "firefox": ">=0.8.0",
    "chrome": ">=16.0.912"
  },
  "readme": "# clarinet\n\n`clarinet` is a sax-like streaming parser for JSON. works in the browser and node.js. `clarinet` is inspired (and forked) from [sax-js][saxjs]. just like you shouldn't use `sax` when you need `dom` you shouldn't use `clarinet` when you need `JSON.parse`. for a more detailed introduction and a performance study please refer to this [article][blog]. \n\n# design goals\n\n`clarinet` is very much like [yajl] but written in javascript:\n\n* written in javascript\n* portable\n* robust (~110 tests pass before even announcing the project)\n* data representation independent\n* fast\n* generates verbose, useful error messages including context of where\n   the error occurs in the input text.\n* can parse json data off a stream, incrementally\n* simple to use\n* tiny\n\n# motivation\n\nthe reason behind this work was to create better full text support in node. creating indexes out of large (or many) json files doesn't require a full understanding of the json file, but it does require something like `clarinet`.\n\n# installation\n\n## node.js\n\n1. install [npm]\n2. `npm install clarinet`\n3. `var clarinet = require('clarinet');`\n\n## browser\n\n1. minimize clarinet.js\n2. load it into your webpage\n\n# usage\n\n## basics\n\n``` js\nvar clarinet = require(\"clarinet\")\n  , parser = clarinet.parser()\n  ;\n\nparser.onerror = function (e) {\n  // an error happened. e is the error.\n};\nparser.onvalue = function (v) {\n  // got some value.  v is the value. can be string, double, bool, or null.\n};\nparser.onopenobject = function (key) {\n  // opened an object. key is the first key.\n};\nparser.onkey = function (key) {\n  // got a key in an object.\n};\nparser.oncloseobject = function () {\n  // closed an object.\n};\nparser.onopenarray = function () {\n  // opened an array.\n};\nparser.onclosearray = function () {\n  // closed an array.\n};\nparser.onend = function () {\n  // parser stream is done, and ready to have more stuff written to it.\n};\n\nparser.write('{\"foo\": \"bar\"}').close();\n```\n\n``` js\n// stream usage\n// takes the same options as the parser\nvar stream = require(\"clarinet\").createStream(options);\nstream.on(\"error\", function (e) {\n  // unhandled errors will throw, since this is a proper node\n  // event emitter.\n  console.error(\"error!\", e)\n  // clear the error\n  this._parser.error = null\n  this._parser.resume()\n})\nstream.on(\"openobject\", function (node) {\n  // same object as above\n})\n// pipe is supported, and it's readable/writable\n// same chunks coming in also go out.\nfs.createReadStream(\"file.json\")\n  .pipe(stream)\n  .pipe(fs.createReadStream(\"file-altered.json\"))\n```\n\n## arguments\n\npass the following arguments to the parser function.  all are optional.\n\n`opt` - object bag of settings regarding string formatting.  all default to `false`.\n\nsettings supported:\n\n* `trim` - boolean. whether or not to trim text and comment nodes.\n* `normalize` - boolean. if true, then turn any whitespace into a single\n  space.\n\n## methods\n\n`write` - write bytes onto the stream. you don't have to do this all at\nonce. you can keep writing as much as you want.\n\n`close` - close the stream. once closed, no more data may be written until\nit is done processing the buffer, which is signaled by the `end` event.\n\n`resume` - to gracefully handle errors, assign a listener to the `error`\nevent. then, when the error is taken care of, you can call `resume` to\ncontinue parsing. otherwise, the parser will not continue while in an error\nstate.\n\n## members\n\nat all times, the parser object will have the following members:\n\n`line`, `column`, `position` - indications of the position in the json\ndocument where the parser currently is looking.\n\n`closed` - boolean indicating whether or not the parser can be written to.\nif it's `true`, then wait for the `ready` event to write again.\n\n`opt` - any options passed into the constructor.\n\nand a bunch of other stuff that you probably shouldn't touch.\n\n## events\n\nall events emit with a single argument. to listen to an event, assign a\nfunction to `on<eventname>`. functions get executed in the this-context of\nthe parser object. the list of supported events are also in the exported\n`EVENTS` array.\n\nwhen using the stream interface, assign handlers using the `EventEmitter`\n`on` function in the normal fashion.\n\n`error` - indication that something bad happened. the error will be hanging\nout on `parser.error`, and must be deleted before parsing can continue. by\nlistening to this event, you can keep an eye on that kind of stuff. note:\nthis happens *much* more in strict mode. argument: instance of `Error`.\n\n`value` - a json value. argument: value, can be a bool, null, string on number\n\n`openobject` - object was opened. argument: key, a string with the first key of the object (if any)\n\n`key` - an object key: argument: key, a string with the current key\n\n`closeobject` - indication that an object was closed\n\n`openarray` - indication that an array was opened\n\n`closearray` - indication that an array was closed\n\n`end` - indication that the closed stream has ended.\n\n`ready` - indication that the stream has reset, and is ready to be written\nto.\n\n## samples\n\nsome [samples] are available to help you get started. one that creates a list of top npm contributors, and another that gets a bunch of data from twitter and generates valid json.\n\n# roadmap\n\ncheck [issues]\n\n# contribute\n\neveryone is welcome to contribute. patches, bug-fixes, new features\n\n1. create an [issue][issues] so the community can comment on your idea\n2. fork `clarinet`\n3. create a new branch `git checkout -b my_branch`\n4. create tests for the changes you made\n5. make sure you pass both existing and newly inserted tests\n6. commit your changes\n7. push to your branch `git push origin my_branch`\n8. create an pull request\n\nhelpful tips:\n\ncheck `index.html`. there's two env vars you can set, `CRECORD` and `CDEBUG`. \n\n* `CRECORD` allows you to `record` the event sequence from a new json test so you don't have to write everything. \n* `CDEBUG` can be set to `info` or `debug`. `info` will `console.log` all emits, `debug` will `console.log` what happens to each char. \n\nin `test/clarinet.js` there's two lines you might want to change. `#8` where you define `seps`, if you are isolating a test you probably just want to run one sep, so change this array to `[undefined]`. `#718` which says `for (var key in docs) {` is where you can change the docs you want to run. e.g. to run `foobar` i would do something like `for (var key in {foobar:''}) {`.\n\n# meta\n\n* code: `git clone git://github.com/dscape/clarinet.git`\n* home: <http://github.com/dscape/clarinet>\n* bugs: <http://github.com/dscape/clarinet/issues>\n* build: [![build status](https://secure.travis-ci.org/dscape/clarinet.png)](http://travis-ci.org/dscape/clarinet)\n\n`(oO)--',-` in [caos]\n\n[npm]: http://npmjs.org\n[issues]: http://github.com/dscape/clarinet/issues\n[caos]: http://caos.di.uminho.pt/\n[saxjs]: http://github.com/isaacs/sax-js\n[yajl]: https://github.com/lloyd/yajl\n[samples]: https://github.com/dscape/clarinet/tree/master/samples\n[blog]: http://writings.nunojob.com/2011/12/clarinet-sax-based-evented-streaming-json-parser-in-javascript-for-the-browser-and-nodejs.html",
  "readmeFilename": "README.md",
  "_id": "clarinet@0.8.1",
  "_from": "clarinet@~0.8.1"
}
